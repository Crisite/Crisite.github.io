<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>函数式编程 | Crisite の博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="lambda、方法引用、Stream流操作~">
<meta property="og:type" content="article">
<meta property="og:title" content="函数式编程">
<meta property="og:url" content="https://crisite.github.io/2024/02/15/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">
<meta property="og:site_name" content="Crisite の博客">
<meta property="og:description" content="lambda、方法引用、Stream流操作~">
<meta property="og:locale">
<meta property="article:published_time" content="2024-02-15T04:35:27.000Z">
<meta property="article:modified_time" content="2024-02-15T09:47:44.000Z">
<meta property="article:author" content="Crisite">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Crisite の博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Crisite の博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Here&#39;s an blog...</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://crisite.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-函数式编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/15/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-02-15T04:35:27.000Z" itemprop="datePublished">2024-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      函数式编程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>lambda、方法引用、Stream流操作~</p>
<span id="more"></span>

<p>函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。历史上研究函数式编程的理论是Lambda演算，所以我们经常把支持函数式编程的编码风格称为Lambda表达式。（看不懂一点）</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>lambda表达式使用的两个依据</p>
<ul>
<li>函数式接口（内部只有一个抽象方法）</li>
<li>javac的类型推断机制（Java是强类型语言，每个变量和对象必须有明确的类型，推断失败时需要手动指定类型）</li>
</ul>
<p>示例一：匿名内部类</p>
<pre><code class="java">List&lt;String&gt; list = Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);
Collections.sort(list, new Comparator&lt;String&gt;()&#123;// 接口名
    @Override
    public int compare(String s1, String s2)&#123;// 方法名
        if(s1 == null)
            return -1;
        if(s2 == null)
            return 1;
        return s1.length()-s2.length();
    &#125;
&#125;);
</code></pre>
<p>lambda表达式：</p>
<pre><code class="java">List&lt;String&gt; list = Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);
Collections.sort(list, (s1, s2) -&gt;&#123;// 省略参数表的类型
    if(s1 == null)
        return -1;
    if(s2 == null)
        return 1;
    return s1.length()-s2.length();
&#125;);
</code></pre>
<h2 id="Lambda表达式的实现"><a href="#Lambda表达式的实现" class="headerlink" title="Lambda表达式的实现"></a>Lambda表达式的实现</h2><p><strong>Lambda表达式通过*invokedynamic*指令实现，书写Lambda表达式不会产生新的类</strong>。</p>
<pre><code class="java">public class MainLambda &#123;
    public static void main(String[] args) &#123;
        new Thread(
                () -&gt; System.out.println(&quot;Lambda Thread run()&quot;)
            ).start();;
    &#125;
&#125;

// javap -c -p MainLambda.class
public class MainLambda &#123;
  ...
  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class java/lang/Thread
       3: dup
       4: invokedynamic #3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable; /*使用invokedynamic指令调用*/
       9: invokespecial #4                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V
      12: invokevirtual #5                  // Method java/lang/Thread.start:()V
      15: return

  private static void lambda$main$0();  /*Lambda表达式被封装成主类的私有方法*/
    Code:
       0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #7                  // String Lambda Thread run()
       5: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return
&#125;
</code></pre>
<p>反编译之后Lambda表达式被封装成了主类的一个私有方法，并通过<em>invokedynamic</em>指令进行调用。</p>
<p>同理，既然Lambda表达式不是内部类的简写，那么Lambda内部的<code>this</code>引用也就跟内部类对象没什么关系了。在Lambda表达式中<code>this</code>的意义跟在表达式外部完全一样。在lambda表达式中的this的意义和外部一样。</p>
<pre><code class="java">public class Hello &#123;
    Runnable r1 = () -&gt; &#123; System.out.println(this); &#125;;
    Runnable r2 = () -&gt; &#123; System.out.println(toString()); &#125;;
    public static void main(String[] args) &#123;
        new Hello().r1.run();
        new Hello().r2.run();
    &#125;
    public String toString() &#123; return &quot;Hello Hoolee&quot;; &#125;
&#125;
</code></pre>
<h2 id="Lambda-and-Collections"><a href="#Lambda-and-Collections" class="headerlink" title="Lambda and Collections"></a>Lambda and Collections</h2><p>为引入Lambda表达式，Java8新增了<code>java.util.funcion</code>包，里面包含常用的<strong>函数接口</strong>，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。</p>
<table>
<thead>
<tr>
<th align="left">接口名</th>
<th align="left">Java8新加入的方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Collection</td>
<td align="left">removeIf() spliterator() stream() parallelStream() forEach()</td>
</tr>
<tr>
<td align="left">List</td>
<td align="left">replaceAll() sort()</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()</td>
</tr>
</tbody></table>
<p>这些新加入的方法部分要用到<code>java.util.function</code>包下的接口，这意味着这些方法部分跟Lambda表达式相关。</p>
<p>以ArrayList的forEach()为例</p>
<p>ArrayList.java</p>
<pre><code class="java">public void forEach(Consumer&lt;? super E&gt; paramConsumer) &#123;
    Objects.requireNonNull(paramConsumer);
    int i = this.modCount;

    Object[] arrayOfObject = this.elementData;
    int j = this.size;
    for (byte b = 0; this.modCount == i &amp;&amp; b &lt; j; b++) &#123;
        paramConsumer.accept((E)arrayOfObject[b]);
    &#125;
    if (this.modCount != i) &#123;
        throw new ConcurrentModificationException();
    &#125;
&#125;
</code></pre>
<p>forEach接收的是一个Consumer对象，这就是function包下的一个函数式接口</p>
<p>Consumer.java</p>
<pre><code class="java">/** 来源 gpt
* 在Java中，虽然Consumer接口中定义了两个方法accept()和andThen()，但它仍然被认为是一个函数式接口。函数式接口是指只包含一个* 抽象方法的接口，可以通过Lambda表达式来实现该接口的方法。即使接口中有默认方法或静态方法，只要它只包含一个抽象方法，仍然可以
* 被视为函数式接口。
*
*在Consumer接口中，accept()方法用于接受一个输入参数并对其执行操作，而andThen()方法用于返回一个组合了当前Consumer和指定*Consumer的新Consumer，以便顺序执行这两个Consumer的操作。
*
*因此，尽管Consumer接口中有多个方法，但只要它只包含一个抽象方法（在这种情况下是accept()），它仍然可以被视为函数式接口。
*/
@FunctionalInterface
public interface Consumer&lt;T&gt;
&#123;
    void accept(T paramT);
  
    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; paramConsumer) &#123;
        Objects.requireNonNull(paramConsumer);
        return paramObject -&gt; &#123;
                accept((T)paramObject);
                paramConsumer.accept(paramObject);
            &#125;;
    &#125;
&#125;
</code></pre>
<p>其他的，像removeIf()、relpaceAll()、sort()、spliterator()等也是同理 省略~</p>
<h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用 ::"></a>方法引用 ::</h1><p>个人理解：当lambda表达式满足特殊条件时，即可使用更简便的方法引用</p>
<p>一个没什么用的例子：</p>
<pre><code class="java">new Thread(() -&gt; System.out.println()).start();
new Thread(System.out::println).start();
</code></pre>
<p>这个例子能使用方法引用因为满足两个条件：</p>
<ul>
<li>函数式接口中调用的方法返回值和接口函数一致</li>
<li>函数式接口中调用的方法参数(列表)和接口函数一致</li>
</ul>
<pre><code class="java">// 匿名内部类 Comparator中没有抽象函数，所以可以自定义一个compare方法
String[] array = ...
Arrays.sort(array, new Comparator&lt;String&gt;() &#123;
    public int compare(String s1, String s2) &#123;
        return s1.compareTo(s2);
    &#125;
&#125;);

// lambda表达式 lambda表达式是对compare方法的简写
Arrays.sort(array, (s1, s2) -&gt; &#123;
    return s1.compareTo(s2);
&#125;);

// 方法引用
Arrays.sort(array, String::compareTo);
</code></pre>
<p>为什么这里能使用方法引用呢？</p>
<p>代码块中Array.sort()的参数为sort( T[], Comparator&lt;? super T&gt;)，Comparator是java.util.function包中的函数式接口</p>
<p>Comparator.java</p>
<pre><code class="java">@FunctionalInterface
public interface Comparator&lt;T&gt; &#123;
    int compare(T paramT1, T paramT2)；
    boolean equals(Object paramObject);
&#125;
</code></pre>
<blockquote>
<p>不知道为什么 equals方法 既没有方法体，也没有default或者static标识，为什么equals不是抽象方法呢？</p>
</blockquote>
<p>在compare方法中返回值为int ，参数为(T, T)此处为String，String</p>
<p>而在String的compareTo方法为public int compareTo(String paramString)二者参数列表好像不一致，但是compare和compareTo却可以匹配</p>
<p>因为实例方法有一个隐含的<code>this</code>参数，<code>String</code>类的<code>compareTo()</code>方法在实际调用的时候，第一个隐含参数总是传入<code>this</code>，相当于静态方法：(为什么System.out.println又没有这个this)（痛苦）</p>
<pre><code>public static int compareTo(String this, String o);
</code></pre>
<h2 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h2><pre><code class="java">public class Main &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; names = List.of(&quot;Bob&quot;, &quot;Alice&quot;, &quot;Tim&quot;);
        List&lt;Person&gt; persons = names.stream().map(Person::new).collect(Collectors.toList());
        System.out.println(persons);
    &#125;
&#125;

class Person &#123;
    String name;
    public Person(String name) &#123;
        this.name = name;
    &#125;
    public String toString() &#123;
        return &quot;Person:&quot; + this.name;
    &#125;
&#125;
</code></pre>
<p>这里的<code>map()</code>需要传入的FunctionalInterface的定义是：</p>
<pre><code class="java">@FunctionalInterface
public interface Function&lt;T, R&gt; &#123;
    R apply(T t);
&#125;
</code></pre>
<p>把泛型对应上就是方法签名<code>Person apply(String)</code>，即传入参数<code>String</code>，返回类型<code>Person</code>。而<code>Person</code>类的构造方法恰好满足这个条件，因为构造方法的参数是<code>String</code>，而构造方法虽然没有<code>return</code>语句，但它会隐式地返回<code>this</code>实例，类型就是<code>Person</code>，因此，此处可以引用构造方法。构造方法的引用写法是<code>类名::new</code>，因此，此处传入<code>Person::new</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>FunctionalInterface</code>允许传入：</p>
<ul>
<li>接口的实现类（传统写法，代码较繁琐）；</li>
<li>Lambda表达式（只需列出参数名，由编译器推断类型）；</li>
<li>符合方法签名的静态方法；</li>
<li>符合方法签名的实例方法（实例类型被看做第一个参数类型）；</li>
<li>符合方法签名的构造方法（实例类型被看做返回类型）。</li>
</ul>
<p><code>FunctionalInterface</code>不强制继承关系，不需要方法名称相同，只要求方法参数（类型和数量）与方法返回类型相同，即认为方法签名相同。</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>晚点再学Stream吧~</p>
<blockquote>
<p>参考文献：大量复制</p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1305207799545890">方法引用</a></p>
<p><a target="_blank" rel="noopener" href="https://objcoding.com/2019/03/04/lambda/#streams-apiii">关于Java Lambda表达式看这一篇就够了</a>(后续的Stream还没看)</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://crisite.github.io/2024/02/15/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" data-id="clz1bxl3p0034gwm694gr5gmc" data-title="函数式编程" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/02/15/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Java线程池
        
      </div>
    </a>
  
  
    <a href="/2024/02/14/Spring-Security%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E4%B9%8B%E6%8E%88%E6%9D%83%E6%B3%A8%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Spring Security权限控制之授权注解</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">-设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Application/" rel="tag">Application</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rabbitmq/" rel="tag">Rabbitmq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Security/" rel="tag">Spring Security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/" rel="tag">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SqlServer/" rel="tag">SqlServer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">高并发分布式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">-设计模式</a> <a href="/tags/Application/" style="font-size: 10px;">Application</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Java/" style="font-size: 18.57px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Mysql/" style="font-size: 15.71px;">Mysql</a> <a href="/tags/RabbitMQ/" style="font-size: 10px;">RabbitMQ</a> <a href="/tags/Rabbitmq/" style="font-size: 10px;">Rabbitmq</a> <a href="/tags/Redis/" style="font-size: 17.14px;">Redis</a> <a href="/tags/Spring-Security/" style="font-size: 14.29px;">Spring Security</a> <a href="/tags/SpringBoot/" style="font-size: 17.14px;">SpringBoot</a> <a href="/tags/SqlServer/" style="font-size: 10px;">SqlServer</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/shell/" style="font-size: 11.43px;">shell</a> <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" style="font-size: 11.43px;">中间件</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 14.29px;">源码</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15.71px;">设计模式</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 12.86px;">项目</a> <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 15.71px;">高并发分布式</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">November 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">October 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/01/Gateway%E7%AE%80%E8%BF%B0/">Gateway简述</a>
          </li>
        
          <li>
            <a href="/2024/07/01/nginx%E7%AE%80%E8%BF%B0/">nginx简述</a>
          </li>
        
          <li>
            <a href="/2024/07/01/%E6%98%BE%E7%A4%BA%E5%99%A8%E5%9C%A8%E4%B8%A4%E4%B8%AA%E8%BE%93%E5%85%A5%E6%BA%90%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2/">显示器在两个输入源中快速切换</a>
          </li>
        
          <li>
            <a href="/2024/06/01/SSH%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/">SSH配置管理</a>
          </li>
        
          <li>
            <a href="/2024/03/22/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">存储过程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Crisite<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>